var documenterSearchIndex = {"docs":
[{"location":"examples/#SWIPL2J-Examples","page":"Examples","title":"SWIPL2J Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"On this page we demonstrate simple examples and use cases.","category":"page"},{"location":"examples/#Basic-stream,-consulting,-and-querying-example","page":"Examples","title":"Basic stream, consulting, and querying example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"filename::String = \"example.pl\"\n\nopen(filename, \"w\")     # Create a file for the example\n\nswipl::IO = SWIPL2J.start_swipl()   # Open an SWI-Prolog process\n\n# Create a new stream for the SWI-Prolog process into the file\nstream::PrologStream = SWIPL2J.open_stream(swipl, filename, :write, false, \"stream_alias\")\n\n# Write some facts into the file\nSWIPL2J.write(stream, \"fruit(apple).\\n\")\nSWIPL2J.write(stream, \"fruit(orange).\\n\")\n\nSWIPL2J.close(stream)   # Close the stream\n\nSWIPL2J.consult_file(swipl, filename)   # Begin consulting the file\n\n# Query an expected boolean value from the SWI-Prolog process\nresult1::Bool = query_bool(swipl, \"fruit(apple)\")\nprintln(\"Result of `fruit(apple)`: $(result1)\")\n\n# As we are not making any more queries to this file, unload it\nSWIPL2J.unload_file(swipl, filename)    # Unload the file since we no longer need it\n\nSWIPL2J.close(swipl)    # Close the SWI-Prolog process","category":"page"},{"location":"examples/#Querying","page":"Examples","title":"Querying","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"SWIPL2J has 4 querying functions, query_bool, query_value, and  query_all_values, and query_manual","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"filename::String = \"example.pl\"\nopen(filename, \"w\")     # Create a file for the example\nswipl::IO = SWIPL2J.start_swipl(filename)\n\n# -----------query_bool------------\nboolean::Bool = SWIPL2J.query_bool(swipl, \"current_predicate(_, person(_,_)).\")\nprintln(\"is apple a fruit? $(boolean)\")\n\n# Open a stream in SWI-Prolog\nstream::PrologStream = SWIPL2J.open_stream(swipl, filename, :append)\nSWIPL2J.write(stream, \"fruit(apple).\\n\")\nSWIPL2J.write(stream, \"fruit(orange).\\n\")\nSWIPL2J.write(stream, \"fruit(pear).\\n\")\nSWIPL2J.write(stream, \"fruit(strawberry).\\n\")\n\n# ----------query_value------------\nstring::String = query_value(swipl, \"stream_property(Stream, alias('$(stream.alias)'))\")\nprintln(\"SWI-Prolog stream: $(string)\")\nSWIPL2J.close(stream)\n\n# --------query_all_values---------\n# This will give an error, as `fruit` does not exist yet in SWI-Prolog\n# not being consulted\nlist::Union{Vector{String}, Nothing} = SWIPL2J.query_all_values(swipl, \"findall(X, fruit(X), L)\")\nprintln(\"List of all fruits before it exists (nothing): $(list)\")\n# Lets consult the file, then query the same thing again\nSWIPL2J.consult_file(swipl, filename)\n# Now we will get the results of our fruit statements\nlist = SWIPL2J.query_all_values(swipl, \"findall(X, fruit(X), L)\")\nprintln(\"List of all fruits: $(list)\")\n\n# ---------query_manual------------\n# Querying manually gives us a simple vector of string containing all output of that query\nmanual_list::Vector{String} = SWIPL2J.query_manual(swipl, \"findall(X, fruit(X), L)\")\nprintln(\"query_manual result of finding all fruits: $(manual_list)\")\n\n# Finally, lets see what happens if a query contains a syntax error\nlist::Union{Vector{String}, Nothing} = SWIPL2J.query_bool(swipl, \"findall(X, fruit(X), L))\")\nprintln(\"Result of an SWI-Prolog query with a syntax error: $(list)\")\n\nSWIPL2J.unload_file(swipl, filename)\n\nSWIPL2J.close(swipl)","category":"page"},{"location":"examples/#Using-Agents.jl","page":"Examples","title":"Using Agents.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"One of the primary motivations for this bridge was to enable logical agents using modern agent toolkits.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example below isn't a particularly compelling one, but demonstrates how one may go about interfacing SWIPL2J and Agents.jl. Note that the Schelling example is superior solely with Agents.jl and the addition of SWIPL2J elements is solely to demonstrate how a developer may choose to integrate modern agent tool kits with logical agents.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing SWIPL2J\nusing Agents # Example was created on stable/tutorial v6.2.9\n\n\n# make the space the agents will live in\nspace = GridSpace((20, 20)) # 20×20 grid cells\n\n#Empty file\nfilename::String = \"example.pl\"\nopen(filename, \"w\")     # Create a file for the example\n\n\n# make an agent type appropriate to this space and with the\n# properties we want based on the ABM we will simulate\n@agent struct Schelling(GridAgent{2}) # inherit all properties of `GridAgent{2}`\n    group::Int # the group does not have a default value!\n    swipl::Base.Process # knowledge base for mood  mood::Bool = false # all agents are sad by default :'(\nend\n\n\n# define the evolution rule: a function that acts once per step on\n# all activated agents (acts in-place on the given agent)\nfunction schelling_step!(agent, model)\n    # Here we access a model-level property `min_to_be_happy`\n    # This will have an assigned value once we create the model\n    minhappy = model.min_to_be_happy\n    count_neighbors_same_group = 0\n    # For each neighbor, get group and compare to current agent's group\n    # and increment `count_neighbors_same_group` as appropriately.\n    # Here `nearby_agents` (with default arguments) will provide an iterator\n    # over the nearby agents one grid cell away, which are at most 8.\n    for neighbor in nearby_agents(agent, model)\n        if agent.group == neighbor.group\n            count_neighbors_same_group += 1\n        end\n    end\n    # After counting the neighbors, decide whether or not to move the agent.\n    # If `count_neighbors_same_group` is at least min_to_be_happy, set the\n    # mood to true. Otherwise, move the agent to a random position, and set\n    # mood to false.\n    if count_neighbors_same_group ≥ minhappy\n        SWIPL2J.write_swipl(agent.swipl, \"retract(mood(X)).\\n\")                 # Access the KB as agent property\n        SWIPL2J.write_swipl(agent.swipl, \"assertz(mood(happy)).\\n\") #initially sad\n    else\n        SWIPL2J.write_swipl(agent.swipl, \"retract(mood(X)).\\n\")\n        SWIPL2J.write_swipl(agent.swipl, \"assertz(mood(sad)).\\n\") #initially sad\n        move_agent_single!(agent, model)\n    end\n    return\nend\n\n# Now that mood is no longer a property of the agent, we cannot leverage adf functionalities in the same way\n# A nice workaround is to have we can have a model property store data for us, and update this on a step call \n# Below loops through each agent queries knowledge-base and stores aggregated info\nfunction model_step!(model)\n    model.sum_mood = 0\n    for n in 1:nagents(model)\n        if SWIPL2J.query_bool(model[n].swipl, \"mood(happy).\") #query an agents KB through the model\n            model.sum_mood += 1\n        end\n    end\n\nend\n\n# make a container for model-level properties\nproperties = Dict(:min_to_be_happy => 3, :sum_mood => 0)\n\n# Create the central `AgentBasedModel` that stores all simulation information\nmodel = StandardABM(\n    Schelling, # type of agents\n    space; # space they live in\n    agent_step! = schelling_step!, \n    model_step! = model_step!,\n    properties\n)\n\n\n\n# populate the model with agents by automatically creating and adding them\n# to random position in the space\nfor n in 1:300\n    print(n)\n    swipl =SWIPL2J.start_swipl()\n    add_agent_single!(model; group = n < 300 / 2 ? 1 : 2, swipl)\n    SWIPL2J.write_swipl(model[n].swipl, \"assertz(mood(sad)).\\n\") #initially sad\nend\n\n# run the model for 5 steps, and collect data.\n# The data to collect are given as a vector of tuples: 1st element of tuple is\n# what property, or what function of agent -> data, to collect. 2nd element\n# is how to aggregate the collected property over all agents in the simulation\nusing Statistics: mean\nxpos(agent) = agent.pos[1]\nmdata = [:sum_mood]\nadf, mdf = run!(model, 5; mdata)\n\n\n# Make sure you close the processes\n# Note, even from this simple implementation you can see one of the primary drawbacks of this method\n# Long close on swipl process, this is because close has a sleep(1) call\n# This was added as a fix for a prior issue, future work may iron this out.\nfor n in 1:300\n    print(n)\n    SWIPL2J.close(model[n].swipl)\nend\nprint(mdf)\nprint(\"Done\")\n\n\n","category":"page"},{"location":"install/#Prerequisites","page":"Install","title":"Prerequisites","text":"","category":"section"},{"location":"install/#Windows","page":"Install","title":"Windows","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"Download Julia https://julialang.org/downloads/\nDownload SWI-Prolog https://www.swi-prolog.org/download/stable\nSet swipl as an environment variable for SWI-Prolog, pointing to the directory containing swipl.exe\nEdit the system and environment variables -> Environment Variables...\nUnder User Variables or System Variables Select Path then Edit...\nAdd a new environment variable by clicking New, then Browse\nSet the new variables path to the bin folder for SWI-Prolog C:\\...\\swipl\\bin","category":"page"},{"location":"install/#Linux","page":"Install","title":"Linux","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"Download Julia https://julialang.org/downloads/\nDownload SWI-Prolog: sudo apt install swi-prolog","category":"page"},{"location":"install/#MacOS","page":"Install","title":"MacOS","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"Download Julia https://julialang.org/downloads/\nDownload SWI-Prolog https://www.swi-prolog.org/download/stable","category":"page"},{"location":"install/#Install-SWIPL2J","page":"Install","title":"Install SWIPL2J","text":"","category":"section"},{"location":"install/","page":"Install","title":"Install","text":"At the Julia REPL, enter the package manager by pressing ] and run:","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"pkg> add https://github.com/Nathanlloyd7/SWIPL2J.jl","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"OR","category":"page"},{"location":"install/","page":"Install","title":"Install","text":"pkg> add SWIPL2J","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#SWIPL2J.PrologStream","page":"Reference","title":"SWIPL2J.PrologStream","text":"PrologStream\n\nA stream object for a SWI-Prolog process.\n\nFields\n\nalias::String: unique stream identifier\nmode::Symbol: mode of stream (:read, :write, or :append)\nfilename::String: name of the active file for the stream\nswipl::IO: reference to the swipl process in which the stream belongs to\n\n\n\n\n\n","category":"type"},{"location":"reference/#SWIPL2J.close-Tuple{IO}","page":"Reference","title":"SWIPL2J.close","text":"close(swipl)\n\nClose the SWI-Prolog instance. https://www.swi-prolog.org/pldoc/doc_for?object=halt/0\n\nArguments\n\nswipl: SWI-Prolog process\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.close-Tuple{PrologStream}","page":"Reference","title":"SWIPL2J.close","text":"close(stream::PrologStream)::Nothing\n\nCloses a stream. streamproperty: https://www.swi-prolog.org/pldoc/docfor?object=streamproperty/2 close: https://www.swi-prolog.org/pldoc/docfor?object=close/1\n\nArguments\n\nstream::PrologStream: stream object for an SWI-Prolog instance\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.consult","page":"Reference","title":"SWIPL2J.consult","text":"consult(swipl, file::String, create_file::Bool = false)\n\nConsult the file for SWI-prolog. https://www.swi-prolog.org/pldoc/doc_for?object=consult/1\n\nArguments\n\nswipl: SWI-Prolog process\nfile::String: file to consult\ncreate_file::Bool=false: silently create the file if it doesn't exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.create_query-Tuple{String}","page":"Reference","title":"SWIPL2J.create_query","text":"create_query(query::String)::String\n\nTurns the given string into a standardized query equipped to handle payload and final result.\n\nhttps://www.swi-prolog.org/pldoc/docfor?object=writeln/1 https://www.swi-prolog.org/pldoc/docfor?object=flush_output/0\n\nArguments\n\nquery::String: a string which will be converted into a larger query\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.echo_term-Tuple{}","page":"Reference","title":"SWIPL2J.echo_term","text":"echo_term()\n\nOpen a terminal connection. https://docs.julialang.org/en/v1/base/io-network/\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.is_prolog_list-Tuple{String}","page":"Reference","title":"SWIPL2J.is_prolog_list","text":"is_prolog_list(string::String):Bool\n\nreturns whether a given string is a prolog list of the form list = [...].\n\nArguments\n\nstring::String: the string to be determined if it is a list\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.open_stream","page":"Reference","title":"SWIPL2J.open_stream","text":"open_stream(swipl, file::String, mode::Symbol = :write, create_file::Bool = false, \nalias::Union{String, Nothing} = nothing)::Union{PrologStream, Nothing}\n\nOpens a file via a stream for reading, writing, or appending. streamproperty: https://www.swi-prolog.org/pldoc/docfor?object=streamproperty/2 open: https://www.swi-prolog.org/pldoc/docfor?object=open/4\n\nArguments\n\nswipl: SWI-Prolog process\nfile::String: active file for the stream\nmode::Symbol=:write: mode in which the stream interacts with the file (:read, :write, or :append)\ncreate_file::Bool=false: silently create the file if it doesn't exist.\nalias::Union{String, Nothing}=nothing: unique string for SWI-Prolog to identify the stream, automatically \n\ngenerated by default\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.parse_prolog_list_line-Tuple{String}","page":"Reference","title":"SWIPL2J.parse_prolog_list_line","text":"parse_prolog_list_line(string::String)::Vector{String}\n\nparses an SWI-Prolog list into a vecctor of strings.\n\nArguments\n\nstring::String: a list as a string\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.prompt_file_creation","page":"Reference","title":"SWIPL2J.prompt_file_creation","text":"prompt_file_creation(file::String, create_file::Bool = false)::Bool\n\nHelper loop to ask prompt the user to create a file.\n\nArguments\n\nfile::String: file to create\ncreate_file::Bool=false: silently create the file if it doesn't exist\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.query_all_values-Tuple{IO, String}","page":"Reference","title":"SWIPL2J.query_all_values","text":"query_all_values(swipl::IO, query::String)::Union{Vector{String}, Nothing}\n\nqueries SWI-Prolog and returns the results as a vector of strings. A query does not have to return multiple results, a non-list result will be wrapped as a string inside the vector. This function is suited for single line results\n\nArguments\n\nswipl::IO: SWI-Prolog process\nquery::String: query to send to SWI-Prolog\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.query_bool-Tuple{IO, String}","page":"Reference","title":"SWIPL2J.query_bool","text":"query_bool(swipl::IO, query::String)::Union{Bool, Nothing}\n\nQueries SWI-Prolog and returns the result of the query as a boolean, returns nothing if the query did not yeild true., or false..\n\nArguments\n\nswipl::IO: SWI-Prolog process\nquery::String: query to send to SWI-Prolog\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.query_manual","page":"Reference","title":"SWIPL2J.query_manual","text":"query_manual(swipl::IO, query::String, read_until_end=true)\n\nSends an unmodified query to SWI-Prolog, reads and returns however many lines passed in as the readlines parameter not including empty lines\n\nArguments\n\nswipl::IO: SWI-Prolog process\nquery::String: query to send to prolog\nread_until_end::Bool=true: number of lines to read after querying, ensure this number is not\n\ngreater than the number of expected lines out the query should return\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.query_swipl-Tuple{IO, String}","page":"Reference","title":"SWIPL2J.query_swipl","text":"query_swipl(swipl::IO, query::String, debug::Bool=false)::NamedTuple{payload::Vector{String}, result::SubString{String}}\n\nSends a query to an SWI-Prolog process, returns a payload and result,  if an error occurrs as a result of the query, the payload will house these error messages.\n\nArguments\n\nswipl::IO: SWI-Prolog process\nquery::String: query to send to SWI-Prolog\ndebug::Bool=false: if true, prints payload.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.query_value-Tuple{IO, String}","page":"Reference","title":"SWIPL2J.query_value","text":"query_value(swipl::IO, query::String)::Union{String, Nothing}\n\nQueries SWI-Prolog and returns the result of the query as a string, returns nothing if an error occured and the query yielded no result.\n\nArguments\n\nswipl::IO: SWI-Prolog process\nquery::String: query to send to SWI-Prolog\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.read_end-Tuple{IO}","page":"Reference","title":"SWIPL2J.read_end","text":"read_end(swipl::IO)::Nothing\n\nReads the lines containing the ending message, the ending message this line reads is how the program confirms a queries output has ended\n\nArguments:\n\n-swipl::IO: an SWI-Prolog process\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.read_prolog_error_alert","page":"Reference","title":"SWIPL2J.read_prolog_error_alert","text":"read_prolog_error_alert(query::Union{String, Nothing} = nothing)\n\nprints a line alerting the user of an SWI-Prolog error, optionally prints the query causing the error.\n\n#Arguments\n\n-query::Union{String, Nothing}=nothing: the query which caused the error, if left as nothing, the alert will not specify any query\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.read_prolog_error_line-Tuple{String}","page":"Reference","title":"SWIPL2J.read_prolog_error_line","text":"read_prolog_error_line(query::Union{String, Nothing} = nothing)\n\nprints a line with an SWI-Prolog error.\n\n#Arguments\n\n-string::String: a line, typially involved in the query\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.save","page":"Reference","title":"SWIPL2J.save","text":"save(swipl, file::String, create_file::Bool = false)\n\nSaves the current facts from SWI-Prologs memory into the given file. tell: https://www.swi-prolog.org/pldoc/docfor?object=tell/1 listing: https://www.swi-prolog.org/pldoc/docfor?object=listing/0 told: https://www.swi-prolog.org/pldoc/doc_for?object=told/0\n\nArguments\n\nswipl: SWI-Prolog process\nfile::String: file to save SWI-Prolog's current memory to\ncreate_file::Bool=false: silently create the file if it doesn't exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.save_stream-Tuple{PrologStream}","page":"Reference","title":"SWIPL2J.save_stream","text":"save(stream::PrologStream)\n\nSave any writes in memory to the streams file. https://www.swi-prolog.org/pldoc/docfor?object=flushoutput/1\n\nArguments\n\nstream::PrologStream: stream object for an SWI-Prolog instance\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.start_swipl","page":"Reference","title":"SWIPL2J.start_swipl","text":"start_swipl(file, create_file)::Union{IO, Nothing}\n\nOpen and return an SWI-Prolog instance with an open file.\n\nArguments\n\nfile::String: name of the file to open the SWI-Prolog context with.\ncreate_file::Bool=false: silently create the file if it doesn't exist.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SWIPL2J.start_swipl-Tuple{}","page":"Reference","title":"SWIPL2J.start_swipl","text":"start_swipl()\n\nOpen and returns an SWI-Prolog process.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.try_create_file-Tuple{String}","page":"Reference","title":"SWIPL2J.try_create_file","text":"try_create_file(file::String, dir::String)::Bool\n\nAttempts to create a file at the given directory, returns a boolean status of the file creation.\n\nArguments\n\nfile::String: file to create\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.unix_path-Tuple{String}","page":"Reference","title":"SWIPL2J.unix_path","text":"unix_path(path::String)::String\n\nReplaces \\ with / to prevent pathing errors\n\nArguments\n\npath::String: file path\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.unload-Tuple{IO, String}","page":"Reference","title":"SWIPL2J.unload","text":"unload(swipl, file::String)\n\nUnload the file as to not include its context for future queries. https://www.swi-prolog.org/pldoc/docfor?object=unloadfile/1\n\nArguments\n\nswipl: SWI-Prolog process\nfile::String: file to unload\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.write-Tuple{PrologStream, String}","page":"Reference","title":"SWIPL2J.write","text":"write(stream::PrologStream, message::String)\n\nWrite into a stream. The result of write depends on the mode of the stream, :append will add  the text to the end of the file, :write will replace the existing file contents with the message. Writing to a stream writes directly into the file, thus using the save function is not required. https://www.swi-prolog.org/pldoc/doc_for?object=write/2\n\nArguments\n\nstream::PrologStream: stream object for an SWI-Prolog instance\nmessage::String: text to write into the stream\n\n\n\n\n\n","category":"method"},{"location":"reference/#SWIPL2J.write_swipl-Tuple{Any, String}","page":"Reference","title":"SWIPL2J.write_swipl","text":"write_swipl(swipl, query::String)::Nothing\n\n(Incomplete Function) Write a line to an SWI-Prolog process.\n\nArguments\n\nswipl: SWI-Prolog process\nquery::String: message to be written to the SWI-Prolog process.\n\n\n\n\n\n","category":"method"},{"location":"#SWIPL2J","page":"Home","title":"SWIPL2J","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SWIPL2J.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J is an API for Julia to interface with SWI-Prolog, providing easy integration between Julia and the logic of Prolog.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#Basics","page":"Home","title":"Basics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To open an SWI-Prolog process, call SWIPL2J.start_swipl, you can also pass in a file to consult once opening","category":"page"},{"location":"","page":"Home","title":"Home","text":"swipl::IO = SWIPL2J.start_swipl()\n# or\nswipl::IO = SWIPL2J.start_swipl(\"example.pl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To close an existing SWI-Prolog process, call close and pass in the SWI-Prolog object","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J.close(swipl)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use SWIPL2J.save to save SWI-Prolog's memory to a file","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Note: will over-write existing file contents\nSWIPL2J.save(swipl, \"example.pl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consult a file with SWIPL2J.consult_file so that the file can be queried","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J.consult_file(swipl, \"example.pl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To unload a consulted file, call SWIPL2J.unload_file","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J.unload_file(swipl, \"example.pl\")","category":"page"},{"location":"#SWI-Prolog-Querying","page":"Home","title":"SWI-Prolog Querying","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are 4 functions to query SWI-Prolog, query_bool, query_value, query_all_values, and query_manual","category":"page"},{"location":"","page":"Home","title":"Home","text":"query_bool returns the result of the query as a boolean, if the result is not true or false the function returns nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"result::Union{Bool, Nothing} = SWIPL2J.query_bool(swipl, \"fruit(apple).\")\n# Expected result:\n#   result = true               if fruit exists and apple is a fruit\n#   result = false              if fruit exists and apple is not a fruit\n#   result = nothing            if fruit does not exist","category":"page"},{"location":"","page":"Home","title":"Home","text":"query_value returns the string result of the query, if the result was an error the function returns nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"result::Union{String, Nothing} = SWIPL2J.query_value(swipl, \"stream_property(Stream, alias('stream_1'))\")\n# Expected result:\n#   result = \"Stream = <stream>(...)\"   if the stream exists\n#   result = \"false.\"                   if the stream does not exist","category":"page"},{"location":"","page":"Home","title":"Home","text":"query_all_values returns the vector of strings resulting from the query, if the result was an error the function returns nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"result::Union{Vector{String}, Nothing} = SWIPL2J.query_all_values(swipl, \"findall(X, fruit(X), L)\")\n# Expected result:\n#   result = [\"apple\", ...]     for apple, and any other fruits that exist\n#   result = nothing            if fruit does not exist","category":"page"},{"location":"","page":"Home","title":"Home","text":"query_manual returns the vector of strings resulting from the query, if the result was an error the function returns nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"result::Union{Vector{String}, Nothing} = SWIPL2J.query_all_values(swipl, \"pwd()\")\n# Result:\n#   result = [\"<working directory>\", \"true.\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"It's important to note the difference between a payload and a result.","category":"page"},{"location":"","page":"Home","title":"Home","text":"query_value(swipl, \"pwd()\")         # Result: \"true.\"\nquery_all_values(swipl, \"pwd()\")    # Result: [\"true.\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may expect either line in the above code to return the working directory as a string (or a string in a vector in the case of query_all_values), however since SWI-Prolog outputs the working directory as a payload, the working directory will not be present in either results, in this case you may want to use query_manual and then take the line you know will contain the working directory. In contrast SWI-Prolog will return a stream as a result, not a payload","category":"page"},{"location":"","page":"Home","title":"Home","text":"query_value(swipl, \"stream_property(Stream, alias('TestStream'))\")\n#   Result: \"Stream = <stream>(...).\"\nquery_all_values(swipl, \"stream_property(Stream, alias('TestStream'))\")\n#   Result: [\"Stream = <stream>(...).\"]","category":"page"},{"location":"#SWI-Prolog-Streams","page":"Home","title":"SWI-Prolog Streams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To open a stream, call SWIPL2J.open_stream with an SWI-Prolog process and a file","category":"page"},{"location":"","page":"Home","title":"Home","text":"stream = SWIPL2J.open_stream(swipl, \"example.pl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To write into a stream, use write with the stream object, and the message to be written or appended into the file","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J.write(stream, \"fruit(apple).\\n\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To close a stream, use SWIPL2J.close with the stream","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J.close(stream)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Save operations of a stream with SWIPL2J.save","category":"page"},{"location":"","page":"Home","title":"Home","text":"SWIPL2J.save(stream)","category":"page"},{"location":"#TODO-List","page":"Home","title":"TODO List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As we are using the terminal, large outputs may be truncated due to limited buffer size, we need utility functions to query the current buffer size (increase of decrease buffer size maybe?) and evaluate outputs as to whether they contain the ... or elipses that signals that the output has been truncated\nMore examples of varying length\nTranslate to a Python package\nRefer to published work using this package\nAlternatives to SWIPL? Can we take advantage of more performant Prolog environments\nPerformance compare herbswipl and julog\nCan we integrate with herbswipl and julog - default to SWIPL2J when, for example, using nested infix operators?\nUse a structure for a swipl process, a property of this structure being a vector of streams.\nCan we safely remove sleep(1) in close()? Vastly decreases performance.","category":"page"}]
}
